#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Программа для расчётов по модели Джелинского–Моранды.
Реализует:
 - оценку общего числа ошибок B̂ методом максимального правдоподобия (численно);
 - вычисление коэффициента K̂;
 - расчёт среднего времени до следующей ошибки X_{n+1};
 - расчёт времени до окончания тестирования.
"""

import math   # подключаем стандартный модуль для математики (ceil, inf и т.п.)

# ------------------------------------------------------------------------------
# Функция: solve_B_newton
# Назначение: найти оценку максимального правдоподобия для B (общее число ошибок)
# Метод: итерации Ньютона для решения нелинейного уравнения
# ------------------------------------------------------------------------------

def solve_B_newton(X, tol=1e-10, maxiter=200):
    n = len(X)              # количество обнаруженных ошибок
    Sx = sum(X)             # сумма всех интервалов между ошибками

    # Функция f(B), которая должна обращаться в ноль (MLE-уравнение)
    def f(B):
        s1 = 0.0
        s2 = 0.0
        for i, Xi in enumerate(X, start=1):
            denom = B - i + 1           # знаменатель B - i + 1
            s1 += 1.0 / denom           # первая сумма: Σ 1/(B - i + 1)
            s2 += denom * Xi            # вторая сумма: Σ (B - i + 1)*Xi
        return s1 - (n * Sx) / s2       # итоговое уравнение

    # Производная f(B), нужна для метода Ньютона
    def fprime(B):
        s1 = 0.0
        s2 = 0.0
        for i, Xi in enumerate(X, start=1):
            denom = B - i + 1
            s1 += 1.0 / (denom * denom)   # сумма 1/(B - i + 1)^2
            s2 += denom * Xi              # Σ (B - i + 1)*Xi
        # формула для производной из условий максимального правдоподобия
        return -s1 + (n * (Sx**2)) / (s2**2)

    # Начальное приближение для B:
    # берём число ошибок n + средний интервал (или хотя бы n+1).
    B = n + max(1.0, Sx / n)
    if B <= n:
        B = n + 1.0

    # Итерационный процесс метода Ньютона
    for it in range(1, maxiter+1):
        val = f(B)             # значение функции f(B)
        deriv = fprime(B)      # значение производной f'(B)

        # Проверка сходимости: если |f(B)| < tol, решение найдено
        if abs(val) < tol:
            return B, it, True

        # Защита: если производная слишком мала → не делим на 0
        if abs(deriv) < 1e-16:
            deriv = 1e-16 if deriv >= 0 else -1e-16

        # Шаг метода Ньютона
        B_new = B - val / deriv

        # Если новое B оказалось ≤ n → корректируем (иначе формулы не работают)
        if B_new <= n:
            B_new = (B + n + 1e-6) / 2.0

        # Если изменение очень маленькое → считаем решение найденным
        if abs(B_new - B) < 1e-12:
            B = B_new
            return B, it, True

        # Обновляем значение и продолжаем
        B = B_new

    # Если не сошлось за maxiter шагов → возвращаем последнее значение
    return B, maxiter, False

# ------------------------------------------------------------------------------
# Функция: compute
# Назначение: вычислить все параметры модели Джелинского–Моранды для данных Xi
# ------------------------------------------------------------------------------

def compute(X):
    n = len(X)                                  # число ошибок
    B_hat, iterations, converged = solve_B_newton(X)  # оценка B̂

    # Коэффициент пропорциональности K̂:
    # K̂ = n / Σ (B̂ - i + 1) * Xi
    denom = sum((B_hat - i + 1) * Xi for i, Xi in enumerate(X, start=1))
    K_hat = n / denom

    # Ожидаемое время до следующей ошибки:
    # X_{n+1} = 1 / (K̂ * (B̂ - n))
    remaining = B_hat - n
    X_next = float('inf') if remaining <= 0 else 1.0 / (K_hat * remaining)

    # Для времени до окончания тестирования берём целое B_int = ceil(B̂)
    B_int = max(n+1, math.ceil(B_hat))
    m = B_int - n                               # сколько ошибок ещё ожидается

    # Гармоническая сумма H_m = Σ (1/k)
    harmonic = sum(1.0 / k for k in range(1, m+1))

    # Время до конца тестирования:
    # T = (1/K̂) * H_m
    time_to_finish = harmonic / K_hat

    # Возвращаем результаты в виде словаря
    return {
        "n": n,
        "B_hat": B_hat,               # оценка общего числа ошибок
        "B_int": B_int,               # округлённое целое значение
        "iterations": iterations,     # количество итераций метода Ньютона
        "converged": converged,       # признак сходимости
        "K_hat": K_hat,               # коэффициент K̂
        "X_next": X_next,             # время до следующей ошибки
        "time_to_finish": time_to_finish,  # время до конца тестирования
        "remaining_real": remaining,  # непрерывная оценка остатка ошибок
        "m": m                        # целое число оставшихся ошибок
    }

# ------------------------------------------------------------------------------
# Главный блок программы
# Здесь задаются данные Xi для 5 вариантов и запускаются расчёты
# ------------------------------------------------------------------------------

if __name__ == "__main__":
    # Списки Xi (часы) для 5 вариантов
    variants = {
#        1: [9,12,11,4,7,2,5,8,5,7,1,6,1,9,4,1,3,3,6,1,11,33,7,91,2,1],
        2: [7,10,12,6,7,3,5,9,5,7,2,6,1,8,3,1,2,3,5,1,84,30,7,3,1],
#        3: [5,4,11,13,6,2,7,5,8,7,1,4,2,7,6,2,3,1,4,78,25,10,7,16,3,1,2],
#        4: [5,8,12,7,6,4,3,7,8,5,2,9,3,6,5,2,4,3,77,2,9,8,10,1,5,3,4,2],
#        5: [4,13,10,5,8,1,6,7,4,9,5,2,3,8,6,3,2,3,94,5,12,8,28,3]
    }

    # Перебираем все варианты и печатаем результаты
    for v, X in variants.items():
        r = compute(X)
        print(
            f"Variant {v}: "
            f"n={r['n']}, "
            f"B_hat={r['B_hat']:.6f}, "
            f"B_int={r['B_int']}, "
            f"K={r['K_hat']:.6e}, "
            f"X_next={r['X_next']:.6f}, "
            f"time_to_finish={r['time_to_finish']:.6f}"
        )
